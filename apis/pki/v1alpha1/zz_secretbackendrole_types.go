/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PolicyIdentifierObservation struct {
}

type PolicyIdentifierParameters struct {

	// Optional CPS URL
	// +kubebuilder:validation:Optional
	Cps *string `json:"cps,omitempty" tf:"cps,omitempty"`

	// Optional notice
	// +kubebuilder:validation:Optional
	Notice *string `json:"notice,omitempty" tf:"notice,omitempty"`

	// OID
	// +kubebuilder:validation:Required
	Oid *string `json:"oid" tf:"oid,omitempty"`
}

type SecretBackendRoleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SecretBackendRoleParameters struct {

	// Flag to allow any name
	// +kubebuilder:validation:Optional
	AllowAnyName *bool `json:"allowAnyName,omitempty" tf:"allow_any_name,omitempty"`

	// Flag to allow certificates matching the actual domain.
	// +kubebuilder:validation:Optional
	AllowBareDomains *bool `json:"allowBareDomains,omitempty" tf:"allow_bare_domains,omitempty"`

	// Flag to allow names containing glob patterns.
	// +kubebuilder:validation:Optional
	AllowGlobDomains *bool `json:"allowGlobDomains,omitempty" tf:"allow_glob_domains,omitempty"`

	// Flag to allow IP SANs
	// +kubebuilder:validation:Optional
	AllowIPSans *bool `json:"allowIpSans,omitempty" tf:"allow_ip_sans,omitempty"`

	// Flag to allow certificates for localhost.
	// +kubebuilder:validation:Optional
	AllowLocalhost *bool `json:"allowLocalhost,omitempty" tf:"allow_localhost,omitempty"`

	// Flag to allow certificates matching subdomains.
	// +kubebuilder:validation:Optional
	AllowSubdomains *bool `json:"allowSubdomains,omitempty" tf:"allow_subdomains,omitempty"`

	// The domains of the role.
	// +kubebuilder:validation:Optional
	AllowedDomains []*string `json:"allowedDomains,omitempty" tf:"allowed_domains,omitempty"`

	// Flag to indicate that `allowed_domains` specifies a template expression (e.g. {{identity.entity.aliases.<mount accessor>.name}})
	// +kubebuilder:validation:Optional
	AllowedDomainsTemplate *bool `json:"allowedDomainsTemplate,omitempty" tf:"allowed_domains_template,omitempty"`

	// Defines allowed custom SANs
	// +kubebuilder:validation:Optional
	AllowedOtherSans []*string `json:"allowedOtherSans,omitempty" tf:"allowed_other_sans,omitempty"`

	// Defines allowed Subject serial numbers.
	// +kubebuilder:validation:Optional
	AllowedSerialNumbers []*string `json:"allowedSerialNumbers,omitempty" tf:"allowed_serial_numbers,omitempty"`

	// Defines allowed URI SANs
	// +kubebuilder:validation:Optional
	AllowedURISans []*string `json:"allowedUriSans,omitempty" tf:"allowed_uri_sans,omitempty"`

	// The path of the PKI secret backend the resource belongs to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-vault/apis/mount/v1alpha1.Mount
	// +kubebuilder:validation:Optional
	Backend *string `json:"backend,omitempty" tf:"backend,omitempty"`

	// +kubebuilder:validation:Optional
	BackendRef *v1.Reference `json:"backendRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	BackendSelector *v1.Selector `json:"backendSelector,omitempty" tf:"-"`

	// Flag to mark basic constraints valid when issuing non-CA certificates.
	// +kubebuilder:validation:Optional
	BasicConstraintsValidForNonCA *bool `json:"basicConstraintsValidForNonCa,omitempty" tf:"basic_constraints_valid_for_non_ca,omitempty"`

	// Flag to specify certificates for client use.
	// +kubebuilder:validation:Optional
	ClientFlag *bool `json:"clientFlag,omitempty" tf:"client_flag,omitempty"`

	// Flag to specify certificates for code signing use.
	// +kubebuilder:validation:Optional
	CodeSigningFlag *bool `json:"codeSigningFlag,omitempty" tf:"code_signing_flag,omitempty"`

	// The country of generated certificates.
	// +kubebuilder:validation:Optional
	Country []*string `json:"country,omitempty" tf:"country,omitempty"`

	// Flag to specify certificates for email protection use.
	// +kubebuilder:validation:Optional
	EmailProtectionFlag *bool `json:"emailProtectionFlag,omitempty" tf:"email_protection_flag,omitempty"`

	// Flag to allow only valid host names
	// +kubebuilder:validation:Optional
	EnforceHostnames *bool `json:"enforceHostnames,omitempty" tf:"enforce_hostnames,omitempty"`

	// Specify the allowed extended key usage constraint on issued certificates.
	// +kubebuilder:validation:Optional
	ExtKeyUsage []*string `json:"extKeyUsage,omitempty" tf:"ext_key_usage,omitempty"`

	// Flag to generate leases with certificates.
	// +kubebuilder:validation:Optional
	GenerateLease *bool `json:"generateLease,omitempty" tf:"generate_lease,omitempty"`

	// The number of bits of generated keys.
	// +kubebuilder:validation:Optional
	KeyBits *float64 `json:"keyBits,omitempty" tf:"key_bits,omitempty"`

	// The generated key type.
	// +kubebuilder:validation:Optional
	KeyType *string `json:"keyType,omitempty" tf:"key_type,omitempty"`

	// Specify the allowed key usage constraint on issued certificates.
	// +kubebuilder:validation:Optional
	KeyUsage []*string `json:"keyUsage,omitempty" tf:"key_usage,omitempty"`

	// The locality of generated certificates.
	// +kubebuilder:validation:Optional
	Locality []*string `json:"locality,omitempty" tf:"locality,omitempty"`

	// The maximum TTL.
	// +kubebuilder:validation:Optional
	MaxTTL *string `json:"maxTtl,omitempty" tf:"max_ttl,omitempty"`

	// Unique name for the role.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Target namespace. (requires Enterprise)
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Flag to not store certificates in the storage backend.
	// +kubebuilder:validation:Optional
	NoStore *bool `json:"noStore,omitempty" tf:"no_store,omitempty"`

	// Specifies the duration by which to backdate the NotBefore property.
	// +kubebuilder:validation:Optional
	NotBeforeDuration *string `json:"notBeforeDuration,omitempty" tf:"not_before_duration,omitempty"`

	// The organization of generated certificates.
	// +kubebuilder:validation:Optional
	Organization []*string `json:"organization,omitempty" tf:"organization,omitempty"`

	// The organization unit of generated certificates.
	// +kubebuilder:validation:Optional
	Ou []*string `json:"ou,omitempty" tf:"ou,omitempty"`

	// Policy identifier block; can only be used with Vault 1.11+
	// +kubebuilder:validation:Optional
	PolicyIdentifier []PolicyIdentifierParameters `json:"policyIdentifier,omitempty" tf:"policy_identifier,omitempty"`

	// Specify the list of allowed policies OIDs.
	// +kubebuilder:validation:Optional
	PolicyIdentifiers []*string `json:"policyIdentifiers,omitempty" tf:"policy_identifiers,omitempty"`

	// The postal code of generated certificates.
	// +kubebuilder:validation:Optional
	PostalCode []*string `json:"postalCode,omitempty" tf:"postal_code,omitempty"`

	// The province of generated certificates.
	// +kubebuilder:validation:Optional
	Province []*string `json:"province,omitempty" tf:"province,omitempty"`

	// Flag to force CN usage.
	// +kubebuilder:validation:Optional
	RequireCn *bool `json:"requireCn,omitempty" tf:"require_cn,omitempty"`

	// Flag to specify certificates for server use.
	// +kubebuilder:validation:Optional
	ServerFlag *bool `json:"serverFlag,omitempty" tf:"server_flag,omitempty"`

	// The street address of generated certificates.
	// +kubebuilder:validation:Optional
	StreetAddress []*string `json:"streetAddress,omitempty" tf:"street_address,omitempty"`

	// The TTL.
	// +kubebuilder:validation:Optional
	TTL *string `json:"ttl,omitempty" tf:"ttl,omitempty"`

	// Flag to use the CN in the CSR.
	// +kubebuilder:validation:Optional
	UseCsrCommonName *bool `json:"useCsrCommonName,omitempty" tf:"use_csr_common_name,omitempty"`

	// Flag to use the SANs in the CSR.
	// +kubebuilder:validation:Optional
	UseCsrSans *bool `json:"useCsrSans,omitempty" tf:"use_csr_sans,omitempty"`
}

// SecretBackendRoleSpec defines the desired state of SecretBackendRole
type SecretBackendRoleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SecretBackendRoleParameters `json:"forProvider"`
}

// SecretBackendRoleStatus defines the observed state of SecretBackendRole.
type SecretBackendRoleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SecretBackendRoleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SecretBackendRole is the Schema for the SecretBackendRoles API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vaultjet}
type SecretBackendRole struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SecretBackendRoleSpec   `json:"spec"`
	Status            SecretBackendRoleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SecretBackendRoleList contains a list of SecretBackendRoles
type SecretBackendRoleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SecretBackendRole `json:"items"`
}

// Repository type metadata.
var (
	SecretBackendRole_Kind             = "SecretBackendRole"
	SecretBackendRole_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SecretBackendRole_Kind}.String()
	SecretBackendRole_KindAPIVersion   = SecretBackendRole_Kind + "." + CRDGroupVersion.String()
	SecretBackendRole_GroupVersionKind = CRDGroupVersion.WithKind(SecretBackendRole_Kind)
)

func init() {
	SchemeBuilder.Register(&SecretBackendRole{}, &SecretBackendRoleList{})
}
